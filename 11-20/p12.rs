// The author of this work hereby waives all claim of copyright (economic and
// moral) in this work and immediately places it in the public domain; it may
// be used, distorted or destroyed in any manner whatsoever without further
// attribution or notice to the creator.

//! Problem 12: Vectors: decode
//!
//! Given a run-length encoded vector generated by the function of the
//! previous problem, construct his uncompressed version.
//!
//! Your function could have this signature:
//! `fn decode<T: Clone>(vec: ~[Node<T>]) -> ~[T]`

enum Node<T> {
    One(T),
    Many(uint, T)
}

fn decode<T: Clone>(list: ~[Node<T>]) -> ~[T] {
    list.move_iter().flat_map(|e|
                match e {
                    One(a)     => {
                        Vec::from_elem(1, a).move_iter()
                    }
                    Many(n, a) => {
                        Vec::from_elem(n, a).move_iter()
                    }
                }).collect()
}

#[test]
fn decode_test() {
    let vec = ~[Many(4, 'a'),
                One('b'),
                Many(2, 'c'),
                Many(2, 'a'),
                One('d'),
                Many(4, 'e')];
    assert_eq!(decode(vec), ~[  'a', 'a', 'a', 'a',
                                'b',
                                'c', 'c',
                                'a', 'a',
                                'd',
                                'e', 'e', 'e', 'e']);
}
